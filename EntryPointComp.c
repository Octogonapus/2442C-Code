#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl7,  leftDriveQuad,  sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  rightDriveQuad, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, launcherQuad,   sensorQuadEncoder)
#pragma config(Motor,  port1,           intakeFeeder,  tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           flyweelY,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           lpY,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightDriveFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightDriveBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           flywheelSecond, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftDriveFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftDriveBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lpSecond,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          intakeDrum,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

//Setup LCD
#define LCD_SAFETY_REQ_COMP_SWITCH
#define MENU_NUM 7
#define USING_QUADS
#define USING_GYRO

#include "Bulldog_Core_Includes.h"
#include "autonFunctions.c"
#include "autonIncludes.h"
#include "programmingSkills.c"

//Auton function prototype
void startAutonomous();

//Menus
menu *driverSkillsMenu;
menu *programmingSkillsMenu;
menu *autonSelectionMenu;
menu *endPreAutonMenu;
menu *batteryVoltageMenu;
menu *powerExpanderVoltageMenu;
menu *backupBatteryVoltageMenu;

//Whether or not to end pre auton
bool endPreAuton = false;

//Auton selection
int autonSelection = -1;

//Launcher velocity controller
bangBang bb;

void pre_auton()
{
  bStopTasksBetweenModes = true;

  //Setups sensors
  initializeSensors();

  //Setup velocity controller
  bangBang_InitController(&bb, launcherQuad, 127, 60);

  //Setup motors
  addMotor(intakeFeeder, MOTOR_FAST_SLEW_RATE);
  addMotor(flyweelY, MOTOR_FAST_SLEW_RATE);
  addMotor(lpY, MOTOR_FAST_SLEW_RATE);
  addMotor(rightDriveFront, MOTOR_FAST_SLEW_RATE);
  addMotor(rightDriveBack, MOTOR_FAST_SLEW_RATE);
  addMotor(flywheelSecond, MOTOR_FAST_SLEW_RATE);
  addMotor(leftDriveFront, MOTOR_FAST_SLEW_RATE);
  addMotor(leftDriveBack, MOTOR_FAST_SLEW_RATE);
  addMotor(lpSecond, MOTOR_FAST_SLEW_RATE);
  addMotor(intakeDrum, MOTOR_FAST_SLEW_RATE);

	//Setup menu system
	autonSelectionMenu = newMenu("Select Auton", 2);
	programmingSkillsMenu = newMenu("Prog Skills", 3);
	driverSkillsMenu = newMenu("Driver Skills", 4);
	endPreAutonMenu = newMenu("Confirm", 1);

	string batteryVoltage;
	sprintf(batteryVoltage, "Main: %1.2f%c", nAvgBatteryLevel / 1000.0, 'V');
	batteryVoltageMenu = newMenu(batteryVoltage);

	string powerExpanderVoltage;
	sprintf(powerExpanderVoltage, "Expander: %1.2f%c", SensorValue[powerExpander] / ANALOG_IN_TO_V, 'V');
	powerExpanderVoltageMenu = newMenu(powerExpanderVoltage);

	string backupBatteryVoltage;
	sprintf(backupBatteryVoltage, "Backup: %1.2f%c", BackupBatteryLevel / 1000.0, 'V');
	backupBatteryVoltageMenu = newMenu(backupBatteryVoltage);

	linkMenus(driverSkillsMenu, programmingSkillsMenu, autonSelectionMenu, endPreAutonMenu, batteryVoltageMenu, powerExpanderVoltageMenu, backupBatteryVoltageMenu);

	bLCDBacklight = true;

	//Wait for user to confirm
	//startTask(updateLCDTask);
	//while (!getLCDSafetyState() && !endPreAuton) { wait1Msec(50); }
}

task autonomous()
{
	startAutonomous();
}

task usercontrol()
{
	startTask(motorSlewRateTask);

	//Drivetrain variables
	int leftV = 0, rightV = 0;

	//Launcher variables
	bool launcherOn = false;
	int targetVelocity = 0, targetVelocity_Increment = 10;

	//LCD variables
	timer lcdTimer;
	timer_Initialize(lcdTimer);
	string lcdLine1, lcdLine2;

	while (true)
	{
		/* ------------ LCD ------------ */

		if (timer_Repeat(&lcdTimer, 100))
		{
			sprintf(lcdLine1, "TV: %d, CV: %d", bangBang_GetTargetVelocity(&bb), bangBang_GetVelocity(&bb));
			displayLCDCenteredString(0, lcdLine1);
		}

		/* ------------ DRIVETRAIN ------------ */

		//Grab values from joystick
		leftV = vexRT[JOY_JOY_LV];
		rightV = vexRT[JOY_JOY_RV];

		//Bound joystick values
		leftV = abs(leftV) < JOY_THRESHOLD ? 0 : leftV;
		rightV = abs(rightV) < JOY_THRESHOLD ? 0 : rightV;

		//Send these values to the drivetrain
		setLeftDriveMotors(leftV);
		setRightDriveMotors(rightV);

		/* -------------- INTAKE -------------- */

		if (vexRT[JOY_TRIG_LD])
		{
			setMotorSpeed(intakeDrum, -127);
		}
		else if (vexRT[JOY_TRIG_LU])
		{
			setMotorSpeed(intakeDrum, 127);
		}
		else
		{
			setMotorSpeed(intakeDrum, 0);
		}

		if (vexRT[JOY_BTN_LU])
		{
			setMotorSpeed(intakeFeeder, 127);
		}
		else if (vexRT[JOY_BTN_LD])
		{
			setMotorSpeed(intakeFeeder, -127);
		}
		else
		{
			setMotorSpeed(intakeFeeder, 0);
		}

		/* -------------- LP -------------- */

		if (vexRT[JOY_TRIG_RU])
		{
			setMotorSpeed(lpY, 127);
			setMotorSpeed(lpSecond, 127);
		}
		else
		{
			setMotorSpeed(lpY, 0);
			setMotorSpeed(lpSecond, 0);
		}

		/* -------------- FLYWHEEL -------------- */

		if (vexRT[JOY_TRIG_RD])
		{
			launcherOn = !launcherOn;
			waitForZero(vexRT[JOY_TRIG_RD]);
		}

		if (launcherOn)
		{
			setMotorSpeed(flyweelY, 127);
			setMotorSpeed(flywheelSecond, 127);
		}
		else
		{
			setMotorSpeed(flyweelY, 0);
			setMotorSpeed(flywheelSecond, 0);
		}

		if (vexRT[JOY_BTN_RU])
		{
			targetVelocity += targetVelocity_Increment;
			waitForZero(vexRT[JOY_BTN_RU]);
		}
		else if (vexRT[JOY_BTN_RD])
		{
			targetVelocity -= targetVelocity_Increment;
			waitForZero(vexRT[JOY_BTN_RD]);
		}

		//Task wait
		wait1Msec(15);
	}
}

//Run an autonomous function based on current selection
void startAutonomous()
{
	//Naming convention: <red side = 1, blue side = 2><left side = 1, right side = 2><primary = 1, secondary = 2, tertiary = 3>

	switch (autonSelection)
	{
		case 111:
			redLeftAutonPrimary();
			break;

		case 112:
			redLeftAutonSecondary();
			break;

		case 113:
			redLeftAutonTertiary();
			break;

		case 121:
			redRightAutonPrimary();
			break;

		case 122:
			redRightAutonSecondary();
			break;

		case 123:
			redRightAutonTertiary();
			break;

		case 211:
			blueLeftAutonPrimary();
			break;

		case 212:
			blueLeftAutonSecondary();
			break;

		case 213:
			blueLeftAutonTertiary();
			break;

		case 221:
			blueRightAutonPrimary();
			break;

		case 222:
			blueRightAutonSecondary();
			break;

		case 223:
			blueRightAutonTertiary();
			break;

		default:
			break;
	}
}

void invoke(int func)
{
	switch (func)
	{
		case 1:
			endPreAuton = true;
			stopTask(updateLCDTask);
			break;

		case 2:
			autonSelection = selectAutonomous();
			break;

		case 3:
			//Run programming skills
			break;

		case 4:
			//Run driver skills
			break;

		default:
			break;
	}
}
