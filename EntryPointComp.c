#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftDriveQuad,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightDriveQuad, sensorQuadEncoder)
#pragma config(Motor,  port1,           intakeOutside, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftDriveFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftDriveBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightDriveFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightDriveBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lpOne,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lpTwo,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lpThree,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          intakeInside,  tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

//Setup LCD
#define LCD_SAFETY_REQ_COMP_SWITCH
#define MENU_NUM 7
#define USING_QUADS
#define USING_GYRO

#include "Bulldog_Core_Includes.h"
#include "autonFunctions.c"
#include "autonIncludes.h"
#include "programmingSkills.c"

//Auton function prototype
void startAutonomous();

//Menus
menu *driverSkillsMenu;
menu *programmingSkillsMenu;
menu *autonSelectionMenu;
menu *endPreAutonMenu;
menu *batteryVoltageMenu;
menu *powerExpanderVoltageMenu;
menu *backupBatteryVoltageMenu;

//Whether or not to end pre auton
bool endPreAuton = false;

//Auton selection
int autonSelection = -1;

void pre_auton()
{
  bStopTasksBetweenModes = true;

  //Setups sensors
  initializeSensors();

  //Setup motors
  addMotor(intakeOutside, MOTOR_FAST_SLEW_RATE);
  addMotor(leftDriveFront, 50);
  addMotor(leftDriveBack, 50);
  addMotor(rightDriveFront, 50);
  addMotor(rightDriveBack, 50);
  addMotor(lpOne, MOTOR_FAST_SLEW_RATE);
  addMotor(lpTwo, MOTOR_FAST_SLEW_RATE);
  addMotor(lpThree, MOTOR_FAST_SLEW_RATE);
  addMotor(intakeInside, MOTOR_FAST_SLEW_RATE);

	//Setup menu system
	autonSelectionMenu = newMenu("Select Auton", 2);
	programmingSkillsMenu = newMenu("Prog Skills", 3);
	driverSkillsMenu = newMenu("Driver Skills", 4);
	endPreAutonMenu = newMenu("Confirm", 1);

	string batteryVoltage;
	sprintf(batteryVoltage, "Main: %1.2f%c", nAvgBatteryLevel / 1000.0, 'V');
	batteryVoltageMenu = newMenu(batteryVoltage);

	string powerExpanderVoltage;
	sprintf(powerExpanderVoltage, "Expander: %1.2f%c", SensorValue[powerExpander] / ANALOG_IN_TO_V, 'V');
	powerExpanderVoltageMenu = newMenu(powerExpanderVoltage);

	string backupBatteryVoltage;
	sprintf(backupBatteryVoltage, "Backup: %1.2f%c", BackupBatteryLevel / 1000.0, 'V');
	backupBatteryVoltageMenu = newMenu(backupBatteryVoltage);

	linkMenus(driverSkillsMenu, programmingSkillsMenu, autonSelectionMenu, endPreAutonMenu, batteryVoltageMenu, powerExpanderVoltageMenu, backupBatteryVoltageMenu);

	bLCDBacklight = true;

	//Wait for user to confirm
	startTask(updateLCDTask);
	while (!getLCDSafetyState() && !endPreAuton) { wait1Msec(50); }
}

task autonomous()
{
	startAutonomous();
}

task usercontrol()
{
	startTask(motorSlewRateTask);

	//Drivetrain variables
	int leftV = 0, rightV = 0;

	while (true)
	{
		/* ------------ DRIVETRAIN ------------ */

		//Grab values from joystick
		leftV = vexRT[JOY_JOY_LV];
		rightV = vexRT[JOY_JOY_RV];

		//Bound joystick values
		leftV = abs(leftV) < JOY_THRESHOLD ? 0 : leftV;
		rightV = abs(rightV) < JOY_THRESHOLD ? 0 : rightV;

		//Send these values to the drivetrain
		setLeftDriveMotors(leftV);
		setRightDriveMotors(rightV);

		/* -------------- INTAKE -------------- */

		if (vexRT[JOY_TRIG_LD])
			setMotorSpeed(intakeOutside, 127);
		else if (vexRT[JOY_TRIG_LU])
			setMotorSpeed(intakeOutside, -127);
		else
			setMotorSpeed(intakeOutside, 0);

		/* -------------- LP -------------- */

		if (vexRT[JOY_TRIG_RU])
		{
			setMotorSpeed(lpOne, 127);
			setMotorSpeed(lpTwo, 127);
			setMotorSpeed(lpThree, 127);
		}
		else
		{
			setMotorSpeed(lpOne, 0);
			setMotorSpeed(lpTwo, 0);
			setMotorSpeed(lpThree, 0);
		}
	}
}

//Run an autonomous function based on current selection
void startAutonomous()
{
	//Naming convention: <red side = 1, blue side = 2><left side = 1, right side = 2><primary = 1, secondary = 2, tertiary = 3>

	switch (autonSelection)
	{
		case 111:
			redLeftAutonPrimary();
			break;

		case 112:
			redLeftAutonSecondary();
			break;

		case 113:
			redLeftAutonTertiary();
			break;

		case 121:
			redRightAutonPrimary();
			break;

		case 122:
			redRightAutonSecondary();
			break;

		case 123:
			redRightAutonTertiary();
			break;

		case 211:
			blueLeftAutonPrimary();
			break;

		case 212:
			blueLeftAutonSecondary();
			break;

		case 213:
			blueLeftAutonTertiary();
			break;

		case 221:
			blueRightAutonPrimary();
			break;

		case 222:
			blueRightAutonSecondary();
			break;

		case 223:
			blueRightAutonTertiary();
			break;

		default:
			break;
	}
}

void invoke(int func)
{
	switch (func)
	{
		case 1:
			endPreAuton = true;
			stopTask(updateLCDTask);
			break;

		case 2:
			autonSelection = selectAutonomous();
			break;

		case 3:
			//Run programming skills
			break;

		case 4:
			//Run driver skills
			break;

		default:
			break;
	}
}
